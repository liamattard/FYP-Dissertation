
\subsection{Producing the activity plan}

After the app generates the dataset of POIs and the
user's travel interest vector, we formulate an
efficient activity plan using these two inputs. This
itinerary generator is based on the existing state of
the art activity planners~\cite{Sylejmani2017, Wisittipanich2020}
with some adjustments: We wanted the trip's output to take the
form of an itinerary.  The problem takes the form of
the `day' and `night'  category split discussed in
the literature review.  The scoring of itineraries is adjusted
with the travel interest vector.

The problem definition of our novel itinerary planner
is mathematically formulated as follows. A tourist trip is made up
of some pre-defined user constants alongside the travel interest
vector. The predefined constants are:
\\
\input{sections/methodology/maths.tex}

\input{sections/methodology/travelProducts.tex}

\subsubsection{Particle Swarm Optimisation}

%TODO: Short description of PSO PSO with bias randomisation
%Flow-chart/algorithm
The algorithm is a population-based technique that uses \textit{n}
elements called particles~\cite{Kennedy}. Each particle has a
d-dimensional \textit{position} vector representing a solution
and a d-dimensional \textit{velocity} vector expressing the
direction of the particle during its search period. 

When a PSO program initialises all of the particles,
they are usually set to a random or predetermined
value. In our algorithm, we introduce a method of
randomisation bias. Although the initial particles are
generated randomly, the randomness is weighted 
by three components: 
\begin{enumerate}
    
    \item The user's travel interest vector 
    \item the place's rating 
    \item the place's number of ratings.

\end{enumerate}
This bias gives a
head start to the algorithm rather than just starting
optimising from purely random itineraries, highly
likely to be of bad quality. Figure X
shows an example of a sample place with its
probability of being chosen as part of the initial
particles alongside a sample tourist interest vector.
At each iteration of the algorithm, the velocity of
each particle is calculated based on the inertia
constant and how well it is doing compared with its
own best score and the global best score. The
inertia constant helps the particle explore new
solutions and escape the local minima. After a few
iterations have passed, particles use this velocity
and move towards the optimum position. We demonstrate
the framework of our PSO algorithm in Figure~\ref{FlowChart}.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{FlowChart.png}
\caption{Framework of PSO algorithm}
\label{FlowChart}
\end{figure}

\subsubsection{Genetic Algorithm}
Genetics algorithms use biological terms to describe
their attributes. For example, in this algorithm, a
timetable solution in population is referred to as a
chromosome. (cite)

The first step is to generate a random population, and
we use the same random bias. In PSO, the algorithm
optimises by allowing each particle to move closer to
the global best every iteration. In comparison, in
GAs, first, the best chromosomes known as the elites
are selected from each iteration. Then, three
techniques, namely selection, mutation, and crossover,
are applied to generate the next population. We show
the framework of this algorithm in figure X. 

\paragraph{Selection}:

\paragraph{Mutation}:

\paragraph{Crossover}:

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{GAFlowchart.png}
\caption{Framework of Genetic algorithm}
\label{FlowChart}
\end{figure}


\subsection{Web application implementation and user
interface}

We built the application using several technologies
where each communicates with each other to provide a
user-friendly website for the potential tourist.
Figure~\ref{TechStack} shows the tech stack diagram of the website.
The website is accessible through the URL
\url{https://www.touristplanner.xyz}. We built the front end of the website using HTML, CSS and javascript and hosted it
on a cloud Vultr server. The website is 
responsive to be accessible from both a
mobile phone and a laptop. The website communicates
with the back end of the application using REST
endpoints, hosted on a separate dedicated server
provided by Hetzner using the Java Spring Boot
framework.  Another Python Gunicorn server is used to
generate the itinerary and calculate a travel interest
vector which sends the information directly to the
Spring boot server. Finally, a local instance of an
Open Source Routing Machine server calculates the
distances from one tourist attraction to another used
by the Gunicorn server to optimise the itinerary. 

\begin{figure}[h]
\centering
\includegraphics[width=0.3\textwidth]{TechStack.png}
\caption{Tech Stack implementation of the application} \label{TechStack}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{Process.png}
\caption{User Experience Timeline}
\label{Timeline}
\end{figure}

Figure~\ref{Timeline} shows screenshots of the website portraying
the user's timeline.  The user navigates to the
homepage, accepts terms and conditions and connect his
social media profiles.  The user selects the number of
days M and the activity moderation C.  The website
navigates to the final page of the application
exhibiting their personalised itinerary. 

\subsection{In-Depth Semi Structured Interviews}
